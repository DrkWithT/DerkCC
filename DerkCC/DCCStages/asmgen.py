"""
    asmgen.py\n
    Modified by DrkWithT\n
    Generates GNU assembler for x64, System V calling conv:\n
    See https://cs.lmu.edu/~ray/notes/gasexamples/\n
    TODO add support for ASM gen using semantics table.
    TODO add logic to better generate if/else: generate sub-sequences of stmt bodies and move them around within a "skeleton" of conditional jumps.\n
    TODO Then generate non-clunky if/else GAS.
"""

from enum import Enum, auto
import DerkCC.DCCStages.ir_types as ir_bits
from DerkCC.DCCStages.ir_visitor import IRVisitor
import DerkCC.DCCStages.asm as gas

## Aliases & Enums ##
IRSteps = list[ir_bits.IRStep]

class LocatorChoice(Enum):
    REGISTER = auto()
    STACKY = auto()
    EITHER = auto()

## Constants #
LOCATION_TABLE_MINSIZE = 16 # there are 16 registers on x64
PLACEHOLDER_INT_SIZE = 8 # hacky patch for now, treat int as 8B

DUD_LOCATOR = '?'

IR_COMPARE_TO_JMP = {
    "COMPARE_NEQ": "jne",
    "COMPARE_EQ": "je",
    "COMPARE_LT": "jl",
    "COMPARE_LTE": "jle",
    "COMPARE_GT": "jg",
    "COMPARE_GTE": "jge"
}

# NOTE temporary table for cmovX's to simulate boolean logic with comparisons.
IR_COMPARE_TO_CMOVX = {
    "COMPARE_NEQ": "cmovne",
    "COMPARE_EQ": "cmove",
    "COMPARE_LT": "cmovl",
    "COMPARE_LTE": "cmovle",
    "COMPARE_GT": "cmovg",
    "COMPARE_GTE": "cmovge"
}

IR_OP_TO_GAS = {
    "CALL": "call",
    "NEGATE": "neg",
    "MULTIPLY": "mul",
    "DIVIDE": "div",
    "ADD": "add",
    "SUBTRACT": "sub",
    "NOP": "nop"
}

## Emitter ##
class GASEmitter(IRVisitor):
    ir_to_gas_loc: gas.MemTable    # tracks IR addresses to GAS locator operands
    gas_reg_pool: dict[str, bool]  # tracks GAS register usage
    temps_n: int             # holds count of stack items corresponding to IR temporaries
    current_argc: int        # tracks running arg total for incoming call
    current_argv: list       # tracks current arg locators for incoming call
    current_arg_stack: list  # tracks pushed args between caller-to-callee
    current_sframe_size: int # tracks total stack frame size for alignment checks
    results: gas.ASMLines    # holds emitted GAS code

    def __init__(self):
        super().__init__()
        self.ir_to_gas_loc = {}
        self.gas_reg_pool = {
            # "%rax": False,
            "%rdi": False,
            "%rsi": False,
            "%rdx": False,
            "%rcx": False,
            "%r8": False,
            "%r9": False,
            "%r10": False,
            "%r11": False
            # TODO add support for other regs as usable (see note below)
            # NOTE the todo needs checks where a preserve stack tracks them
        }
        self.temps_n = 0
        self.current_argc = 0
        self.current_argv = []
        self.current_arg_stack = []
        self.current_sframe_size = 0
        self.results = []

    def record_location(self, locator: str, gas_locator: str):
        self.ir_to_gas_loc[locator] = gas.LocationInfo(gas_locator, True)

    def lookup_location(self, locator: str) -> gas.LocationInfo:
        return self.ir_to_gas_loc[locator]

    def toggle_location_usage(self, locator: str):
        flip = not self.ir_to_gas_loc.get(locator).used
        self.ir_to_gas_loc[locator].used = flip

    def cull_temp_locations(self):
        locator_ids = self.ir_to_gas_loc.keys()

        for loc_id in locator_ids:
            # NOTE I can remove all temps by 1 fact: they're always stored under RBP in stack frames, so I just check for the '-' prefix of `-n(%rbp)`.
            peeked_entry = self.ir_to_gas_loc.get(loc_id) or DUD_LOCATOR

            if peeked_entry[0] == '-':
                del self.ir_to_gas_loc[loc_id]

    def get_register_choices(self) -> list[str]:
        return [reg_id for reg_id in self.gas_reg_pool.keys()]

    def allocate_location(self, ir_locator: str, option: LocatorChoice) -> str:
        if option != LocatorChoice.STACKY:
            free_regs = self.get_register_choices()

            for reg in free_regs:
                if not self.gas_reg_pool.get(reg):
                    self.gas_reg_pool[reg] = True
                    self.record_location(ir_locator, reg)
                    return reg

        if option == LocatorChoice.REGISTER:
            return None

        self.temps_n += 1
        # TODO support both int and char... needs earlier type info in "sem"
        temp_result = f'{(self.temps_n * -PLACEHOLDER_INT_SIZE)}(%rbp)'
        self.record_location(ir_locator, temp_result)

        return temp_result

    def emit_all(self, steps: IRSteps) -> gas.ASMLines:
        self.results.append('; generated by DCC v0.1 alpha\n')
        for step in steps:
            step.accept_visitor(self)

        return self.results

    def visit_label(self, step: ir_bits.IRStep):
        label_name: str = step.title

        if label_name[0] == 'L':
            self.results.append(f'{step.title}:\n')
        else:
            self.results.append(f'.global {label_name}\n')
            self.results.append(f'{label_name}:\n')
            self.results.append(f'\tpushq %rbp\n')
            self.results.append(f'\tmovq %rsp, %rbp\n')
            self.current_sframe_size = PLACEHOLDER_INT_SIZE + self.current_argc * PLACEHOLDER_INT_SIZE

    def visit_return(self, step: ir_bits.IRStep):
        ir_addr: str = step.result_addr
        result_info = self.lookup_location(ir_addr)
        result_addr = result_info.gas_name if result_info is not None else self.allocate_location(ir_addr, LocatorChoice.EITHER)

        self.results.append(f'\tmovq {result_addr}, %rax\n')
        self.results.append(f'\tpopq %rbp\n')
        self.toggle_location_usage(ir_addr)
        self.current_sframe_size = 0
        self.temps_n = 0
        self.current_argc = 0
        self.cull_temp_locations()

    def visit_jump(self, step: ir_bits.IRStep):
        target_label: str = step.target
        self.results.append(f'\tjmp {target_label}\n')

    def visit_jump_if(self, step: ir_bits.IRStep):
        target_label: str = step.target
        step_op: ir_bits.IROp = step.op
        step_arg_0: str | int = step.arg0
        step_arg_1: str | int = step.arg1

        jump_op = IR_COMPARE_TO_JMP.get(step_op)

        # NOTE handle args based on type: int is immediate, str is locator
        gas_arg_0 = f'${step_arg_0}' if step_arg_0.strip is None else self.lookup_location(step_arg_0) or self.allocate_location(step_arg_0, LocatorChoice.EITHER)
        gas_arg_1 = f'${step_arg_1}' if step_arg_1.strip is None else self.lookup_location(step_arg_1) or self.allocate_location(step_arg_1, LocatorChoice.EITHER)

        self.results.append(f'\tcmp {gas_arg_1}, {gas_arg_0}\n')
        self.results.append(f'\t{jump_op} {target_label}')
        self.toggle_location_usage(step_arg_1)
        self.toggle_location_usage(step_arg_0)

    def visit_push_arg(self, step: ir_bits.IRStep):
        """
            Algorithm:
            1. While there is an `IRPushArg` step:
                * Append it to the arg list as `(gas_location: str, on_stack: bool = count <= 6)`.
                * Increase count by 1.
            2. While there is another arg in the list:
                * If an arg's `on_stack` flag is `False`:
                    * Set the next available argument register to the argument. "Free" the source as needed.
                * Else:
                    * Take the arg from the end before placing a push instruction... The stacky area must be accessed bottom up.
        """
        ir_addr: str | int = step.arg

        if self.current_argc < 6:
            gas_arg_src = self.lookup_location(ir_addr)
            gas_arg_dest = self.allocate_location(ir_addr, LocatorChoice.EITHER)
            self.current_argv.append(gas_arg_dest)
            self.results.append(f'\tmovq {gas_arg_src}, {gas_arg_dest}\n')
        else:
            gas_arg_src = self.allocate_location(ir_addr, LocatorChoice.STACKY)
            self.results.append(f'\tpushq {gas_arg_src}')

        self.current_argc += 1

    def visit_call_func(self, step: ir_bits.IRStep):
        # NOTE align the stack by a 16-multiple before call... maybe an extra 8 residue is there... exclude 6 register args!
        # NOTE assume all operands are quads for hacky purposes
        if (self.current_argc - 6) % 2 != 0:
            self.current_arg_stack.append(None)
            self.results.append(f'\tpushq $0\n')

        self.results.append(f'\tcall {step.callee}\n')

    def visit_assign(self, step: ir_bits.IRStep):
        ir_dest_addr: str = step.dest
        ir_op: ir_bits.IrOp = step.op
        gas_dest_opt = self.lookup_location(ir_dest_addr)
        gas_dest_addr: str = gas_dest_opt.gas_name if gas_dest_opt is not None else self.allocate_location(ir_arg_0, LocatorChoice.EITHER)

        gas_op: str = IR_OP_TO_GAS.get(ir_op)
        ir_arg_0: str | int = step.operands[0]
        ir_arg_1: str | int = step.operands[1]

        gas_arg_0 = f'${ir_arg_0}' if ir_arg_0.strip is None else self.lookup_location(ir_arg_0) or self.allocate_location(ir_arg_0, LocatorChoice.EITHER)

        # handle no-arg ops
        if gas_op == 'nop':
            if ir_dest_addr == ir_arg_0 or ir_dest_addr == ir_arg_1:
                return

            self.results.append(f'\tmovq {gas_arg_0}, {gas_dest_addr}\n')
            return

        # handle unary ops
        if gas_op == 'neg':
            temp_src = self.lookup_location(ir_arg_0).gas_name
            self.results.append(f'\tneg {temp_src}\n')
            self.results.append(f'\tmovq {temp_src}, {gas_dest_addr}')
            return

        # handle 2 cases of binary ops: arithmetic or comparison
        gas_arg_1 = f'${ir_arg_1}' if ir_arg_1.strip is None else self.lookup_location(ir_arg_1) or self.allocate_location(ir_arg_1, LocatorChoice.EITHER)

        # arithmetic
        if gas_op == 'add':
            self.results.append(f'\t{gas_op} {gas_arg_0}, {gas_arg_1}\n')
            self.results.append(f'\tmovq {gas_arg_0}, {gas_dest_addr}\n')
        elif gas_op == 'sub':
            self.results.append(f'\t{gas_op} {gas_arg_1}, {gas_arg_0}\n')
            self.results.append(f'\tmovq {gas_arg_0}, {gas_dest_addr}\n')
        # elif gas_op == 'mul':
            # pass
        # elif gas_op == 'div':
            # pass

        gas_comp_op = IR_COMPARE_TO_CMOVX.get(ir_op)

        # TODO please remove when the top-level refactoring task is done!
        if not gas_comp_op:
            raise RuntimeError(f'asmgen.py: Unsupported gas_comp_op in generation: {ir_op}')

        self.results.append(f'\tmovq $0, {gas_dest_addr}')
        self.results.append(f'\tcmp {gas_arg_1}, {gas_arg_0}\n')
        self.results.append(f'\t{gas_comp_op} $1, {gas_dest_addr}\n')

        self.toggle_location_usage(gas_arg_1)
        self.toggle_location_usage(gas_arg_0)

    def visit_load_const(self, step: ir_bits.IRStep):
        ir_const_addr: str = step.addr
        ir_constant: int = step.value

        gas_addr = self.allocate_location(ir_const_addr, LocatorChoice.STACKY)
        self.results.append(f'\tmovq ${ir_constant}, {gas_addr}\n')
