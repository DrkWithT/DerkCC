"""
    asmgen.py\n
    Modified by DrkWithT\n
    Generates GNU assembler for x64, System V calling convention.\n
    Sources:
    [GAS LMU Lecture](https://cs.lmu.edu/~ray/notes/gasexamples/)\n
    [9cc gen_x86 code](https://github.com/rui314/9cc/blob/master/gen_x86.c)\n
    TODO Overhaul the register/location allocation logic... see 9cc code.
"""

from enum import Enum, auto
import DerkCC.DCCStages.ir_types as ir_bits
import DerkCC.DCCStages.ir_gen as ir_gen
from DerkCC.DCCStages.ir_visitor import IRVisitor
import DerkCC.DCCStages.asm as gas

## Aliases & Enums ##
IRSteps = list[ir_bits.IRStep]

class LocatorChoice(Enum):
    REGISTER = auto()
    STACKY = auto()
    EITHER = auto()

## Constants #
LOCATION_TABLE_MINSIZE = 16 # there are 16 registers on x64

IR_COMPARE_TO_JMP = {
    "COMPARE_NEQ": "jne",
    "COMPARE_EQ": "je",
    "COMPARE_LT": "jl",
    "COMPARE_LTE": "jle",
    "COMPARE_GT": "jg",
    "COMPARE_GTE": "jge"
}

# NOTE temporary table for cmovX's to simulate boolean logic with comparisons.
IR_COMPARE_TO_CMOVX = {
    "COMPARE_NEQ": "cmovne",
    "COMPARE_EQ": "cmove",
    "COMPARE_LT": "cmovl",
    "COMPARE_LTE": "cmovle",
    "COMPARE_GT": "cmovg",
    "COMPARE_GTE": "cmovge"
}

IR_OP_TO_GAS = {
    "CALL": "call",
    "NEGATE": "neg",
    "MULTIPLY": "mul",
    "DIVIDE": "div",
    "ADD": "add",
    "SUBTRACT": "sub",
    "NOP": "nop"
}

## Utility functions ##

def roundup_offset(acc_offset: int, align_n: int = 16):
    mask = align_n - 1
    return (acc_offset + mask) & ~(mask)

## Emitter ##
class GASEmitter(IRVisitor):
    results: gas.ASMLines

    def __init__(self, funcs: ir_gen.FuncInfoTable):
        super().__init__()
        self.results = []

    def emit_all(self, steps: IRSteps) -> gas.ASMLines:
        self.results.append('; generated by DCC v0.1 alpha\n')
        self.results.append('.text\n')
        for step in steps:
            step.accept_visitor(self)

        return self.results

    def visit_label(self, step: ir_bits.IRStep):
        label_name: str = step.title

        if label_name[0] == 'L':
            self.results.append(f'{step.title}:\n')
        else:
            self.results.append(f'.global {label_name}\n')
            self.results.append(f'{label_name}:\n')

            # NOTE here, just allocate the stack frame
            self.results.append(f'\tpushq %rbp\n')
            self.results.append(f'\tmovq %rsp, %rbp\n')

            # FIXME allocate stack frame for locals too... see 9cc local counter and use ir_gen's func_infos.
            pass

    def visit_return(self, step: ir_bits.IRStep):
        pass # FIXME

    def visit_jump(self, step: ir_bits.IRStep):
        target_label: str = step.target
        self.results.append(f'\tjmp {target_label}\n')

    def visit_jump_if(self, step: ir_bits.IRStep):
        pass # FIXME

    def visit_push_arg(self, step: ir_bits.IRStep):
        """
            Algorithm:
            1. While there is an `IRPushArg` step:
                * Append it to the arg list as `(gas_location: str, on_stack: bool = count <= 6)`.
                * Increase count by 1.
            2. While there is another arg in the list:
                * If an arg's `on_stack` flag is `False`:
                    * Set the next available argument register to the argument. "Free" the source as needed.
                * Else:
                    * Take the arg from the end before placing a push instruction... The stacky area must be accessed bottom up.
        """
        ir_addr: str | int = step.arg

        if self.current_argc < 6:
            pass # FIXME
        else:
            pass # FIXME

    def visit_call_func(self, step: ir_bits.IRStep):
        self.results.append(f'\tpush %r10\n')
        self.results.append(f'\tpush %r11\n')
        self.results.append(f'\txor %rax, %rax\n')
        self.results.append(f'\tcall {step.callee}\n')
        self.results.append(f'\tpop %r11\n')
        self.results.append(f'\tpop %r10\n')

    def visit_assign(self, step: ir_bits.IRStep):
        pass # FIXME

    def visit_load_const(self, step: ir_bits.IRStep):
        ir_const_addr: str = step.addr
        ir_constant: int = step.value
        pass # FIXME
